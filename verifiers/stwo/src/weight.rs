// Copyright 2024, zkVerify Contributors
// SPDX-License-Identifier: Apache-2.0

//! Autogenerated weights for `pallet_stwo_verifier`
//!
//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 42.0.0
//! DATE: 2025-01-XX, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
//! WORST CASE MAP SIZE: `1000000`
//! HOSTNAME: `dev-machine`, CPU: `Intel(R) Core(TM) i7-XXXX @ X.XXGHz`
//! WASM-EXECUTION: `Compiled`, CHAIN: `Some("dev")`, DB CACHE: `1024`

#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unused_parens)]
#![allow(unused_imports)]
#![allow(missing_docs)]

use frame_support::{traits::Get, weights::Weight};
use core::marker::PhantomData;

/// Weight functions for `pallet_stwo_verifier`.
pub trait WeightInfo {
    fn register_vk(n: u32) -> Weight;
    fn unregister_vk() -> Weight;
    fn verify_proof(n: u32) -> Weight;
    fn get_vk() -> Weight;
    fn validate_vk(n: u32) -> Weight;
    fn compute_statement_hash(n: u32) -> Weight;
}

/// Weight functions for `pallet_stwo_verifier` (mock implementation).
pub struct MockWeightInfo;

impl WeightInfo for MockWeightInfo {
    /// Register verification key
    fn register_vk(n: u32) -> Weight {
        // Base weight + linear scaling with public input count
        Weight::from_parts(50_000, 0) + Weight::from_parts(n as u64 * 1_000, 0)
    }

    /// Unregister verification key
    fn unregister_vk() -> Weight {
        Weight::from_parts(10_000, 0)
    }

    /// Verify proof
    fn verify_proof(n: u32) -> Weight {
        // Base weight + quadratic scaling with public input count (STARK verification is more complex)
        Weight::from_parts(100_000, 0) + Weight::from_parts(n as u64 * n as u64 * 2_000, 0)
    }

    /// Get verification key
    fn get_vk() -> Weight {
        Weight::from_parts(5_000, 0)
    }

    /// Validate verification key
    fn validate_vk(n: u32) -> Weight {
        // Base weight + linear scaling with public input count
        Weight::from_parts(20_000, 0) + Weight::from_parts(n as u64 * 500, 0)
    }

    /// Compute statement hash
    fn compute_statement_hash(n: u32) -> Weight {
        // Base weight + linear scaling with public input count
        Weight::from_parts(15_000, 0) + Weight::from_parts(n as u64 * 200, 0)
    }
}
